<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mail 2 U - Write</title>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0" />
    <link rel="stylesheet" href="./material3.css" />

    <!-- React & MUI Dependencies -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/@mui/material@5.16.1/umd/material-ui.development.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="./db.js"></script>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;
        const MaterialUI = window.MaterialUI || window.Mui;
        const {
            createTheme, ThemeProvider, CssBaseline,
            Container, Box, Paper, Typography, TextField, Button,
            Stack, Chip, AppBar, Toolbar, IconButton, Fab,
            Dialog, DialogTitle, DialogContent, DialogContentText, DialogActions,
            ToggleButton, ToggleButtonGroup, List, ListItem, ListItemText,
            Menu, MenuItem, Divider,
            FormControl, InputLabel, Select, CircularProgress,
            Tabs, Tab, Snackbar,
            Table, TableHead, TableRow, TableCell, TableBody, TableContainer
        } = MaterialUI;

        const THEMES = [
            { id: 'm3_purple', color: '#6750A4', name: 'M3 퍼플' },
            { id: 'mint', color: '#008272', name: '민트 틸' },
            { id: 'berry', color: '#0067C0', name: '오션 블루' },
            { id: 'candy', color: '#E3008C', name: '캔디 핑크' },
            { id: 'forest', color: '#004E4C', name: '포레스트 그린' },
            { id: 'pumpkin', color: '#D83B01', name: '펌킨 오렌지' },
            { id: 'zinc', color: '#505050', name: '징크 그레이' },
        ];

        function App() {
            const [form, setForm] = useState({
                subject: '', receiverName: '', receiverRole: '',
                senderName: '', senderRole: '', content: '',
                phone: '', email: '', driveLink: '', theme: 'm3_purple',
                contentType: 'text',
                password: '', // Raw input (not saved)
                // New Fields
                receivers: '', // For Multi-Send
                messages: [] // For Rolling Paper: [{ senderName, senderRole, content }]
            });
            const [snackbar, setSnackbar] = useState({ open: false, message: '' });
            const [mode, setMode] = useState('general'); // 'general' | 'multi' | 'rolling'
            const [resultUrl, setResultUrl] = useState('');
            const [originUrl, setOriginUrl] = useState('');
            const [qrFallback, setQrFallback] = useState(false);
            const [multiResults, setMultiResults] = useState([]); // [{ name, url }]
            const [csvData, setCsvData] = useState(null); // { type: 'rolling', groups: {} }

            // Autocomplete State
            const [anchorEl, setAnchorEl] = useState(null);
            const [cursorPos, setCursorPos] = useState(0);

            // Rolling Paper Input State
            const [rollingInput, setRollingInput] = useState({ senderName: '', senderRole: '', content: '' });

            // Quill Ref
            const quillRef = useRef();
            const editorRef = useRef();

            // Profile State
            const [profiles, setProfiles] = useState([]);
            const [selectedProfile, setSelectedProfile] = useState('');

            const qrRef = useRef();

            // Initialize Quill
            useEffect(() => {
                if (form.contentType === 'html' && !editorRef.current) {
                    // Small delay to ensure DOM render
                    setTimeout(() => {
                        if (document.getElementById('editor')) {
                            editorRef.current = new Quill('#editor', {
                                theme: 'snow',
                                modules: {
                                    toolbar: [
                                        [{ 'header': [1, 2, false] }],
                                        ['bold', 'italic', 'underline', 'strike'],
                                        [{ 'color': [] }, { 'background': [] }],
                                        [{ 'list': 'ordered' }, { 'list': 'bullet' }],
                                        ['link', 'image', 'video'],
                                        ['clean']
                                    ]
                                }
                            });
                            editorRef.current.on('text-change', (delta, oldDelta, source) => {
                                setForm(prev => ({ ...prev, content: editorRef.current.root.innerHTML }));

                                // Autocomplete trigger for Quill
                                if (source === 'user') {
                                    const selection = editorRef.current.getSelection();
                                    if (selection) {
                                        const index = selection.index;
                                        const text = editorRef.current.getText(index - 2, 2);
                                        if (text === '/{') {
                                            setAnchorEl(document.getElementById('editor'));
                                            setCursorPos(index);
                                        }
                                    }
                                }
                            });
                            // Set initial content if exists
                            if (form.content) editorRef.current.root.innerHTML = form.content;
                        }
                    }, 100);
                }
            }, [form.contentType]);

            // 1. Load Draft OR Edit
            useEffect(() => {
                const init = async () => {
                    // Load Profile list
                    const storedProfiles = localStorage.getItem('mail2u_profiles');
                    if (storedProfiles) setProfiles(JSON.parse(storedProfiles));

                    // Load Data
                    const params = new URLSearchParams(window.location.search);
                    const draftId = params.get('draftId');

                    if (draftId) {
                        const d = await window.LetterDB.get(draftId);
                        if (d) {
                            setForm(d);
                            if (d.receivers) setMode('multi');
                            if (d.messages && d.messages.length > 0) setMode('rolling');
                            if (d.contentType === 'html' && editorRef.current) {
                                editorRef.current.root.innerHTML = d.content;
                            }
                        }
                    } else {
                        // New Letter: Generate Random ID immediately
                        const newId = await window.LetterDB.generateRandomId();
                        setForm(prev => ({ ...prev, id: newId }));

                        const newUrl = new URL(window.location);
                        newUrl.searchParams.set('draftId', newId);
                        window.history.replaceState({}, '', newUrl);
                    }
                };
                init();
            }, []);

            // Auto Save to DB on Change (Instant Draft)
            useEffect(() => {
                if (form.id && (form.subject || form.content || form.receiverName || form.senderName)) {
                    // Save draft silently
                    const draftData = {
                        ...form,
                        mailbox: ['draft'],
                        updatedAt: new Date().toISOString()
                        // Note: Password remains raw in draft for easy editing
                    };
                    window.LetterDB.save(draftData).catch(console.error);
                }
            }, [form]);

            // Dynamic M3 Theme
            const theme = createTheme({
                typography: {
                    fontFamily: `'Roboto', 'Pretendard', sans-serif`,
                    h6: { fontWeight: 500 },
                    button: { textTransform: 'none', fontWeight: 500 }
                },
                palette: {
                    primary: { main: THEMES.find(t => t.id === form.theme)?.color || '#6750A4' },
                    secondary: {
                        main: (THEMES.find(t => t.id === form.theme)?.color || '#6750A4') + 'AA',
                        container: (THEMES.find(t => t.id === form.theme)?.color || '#6750A4') + '20',
                        onContainer: (THEMES.find(t => t.id === form.theme)?.color || '#6750A4')
                    },
                    background: { default: (THEMES.find(t => t.id === form.theme)?.color || '#6750A4') + '08', paper: '#FFFFFF' },
                    surfaceVariant: { main: (THEMES.find(t => t.id === form.theme)?.color || '#6750A4') + '15', onMain: '#49454F' },
                    text: { primary: '#1D1B20', secondary: '#49454F' },
                },
                components: {
                    MuiCssBaseline: {
                        styleOverrides: `
                            :root {
                                --T_primary: ${THEMES.find(t => t.id === form.theme)?.color || '#6750A4'};
                                --T_background: ${(THEMES.find(t => t.id === form.theme)?.color || '#6750A4')}08;
                                --T_surface: #FFFFFF;
                                --T_surfaceContainer: ${(THEMES.find(t => t.id === form.theme)?.color || '#6750A4')}15;

                                --L_primary: var(--T_primary);
                                --L_container: var(--T_surfaceContainer);
                            }
                            body { background-color: var(--T_background) !important; }
                        `
                    },
                    MuiTextField: {
                        defaultProps: { variant: 'outlined', fullWidth: true, size: 'small' },
                        styleOverrides: {
                            root: {
                                '& .MuiOutlinedInput-root': {
                                    borderRadius: 12,
                                    backgroundColor: 'var(--T_surfaceContainer)',
                                    '& fieldset': { borderColor: 'transparent' },
                                    '&:hover fieldset': { borderColor: 'var(--T_primary)', opacity: 0.5 },
                                    '&.Mui-focused fieldset': { borderColor: 'var(--T_primary)', borderWidth: 2 }
                                }
                            }
                        }
                    },
                    MuiPaper: {
                        defaultProps: { elevation: 0 },
                        styleOverrides: { root: { borderRadius: 16 } }
                    },
                    MuiButton: {
                        styleOverrides: {
                            root: { borderRadius: 20, padding: '10px 24px', textTransform: 'none' },
                            contained: { boxShadow: 'none' }
                        }
                    },
                    MuiFab: {
                        styleOverrides: {
                            root: {
                                borderRadius: 16,
                                '&.MuiFab-extended': { borderRadius: 28, padding: '0 24px' }
                            }
                        }
                    },
                    MuiDialog: {
                        styleOverrides: {
                            paper: { borderRadius: 28, padding: '0', overflow: 'hidden', boxShadow: '0 24px 48px rgba(0,0,0,0.2)' }
                        }
                    },
                    MuiChip: {
                        styleOverrides: {
                            root: { borderRadius: 8, fontWeight: 500 },
                            filled: { border: 'none' },
                            outlined: { borderColor: 'var(--md-sys-color-outline)' }
                        }
                    },
                    MuiAppBar: {
                        styleOverrides: {
                            root: { backgroundColor: 'var(--md-sys-color-surface)', color: 'var(--md-sys-color-on-surface)', boxShadow: 'none' }
                        }
                    }
                }
            });

            const handleChange = (e) => {
                const { name, value } = e.target;
                setForm(prev => ({ ...prev, [name]: value }));

                // Autocomplete Trigger for 'content' field
                if (name === 'content') {
                    const lastTwo = value.slice(e.target.selectionStart - 2, e.target.selectionStart);
                    if (lastTwo === '/{') {
                        setAnchorEl(e.target); // It won't be exact caret position but it works for context
                        setCursorPos(e.target.selectionStart);
                    }
                }
            };

            const handleVarSelect = (varName) => {
                const varText = varName.endsWith(':') ? varName : varName + '}';
                if (form.contentType === 'html' && editorRef.current) {
                    editorRef.current.insertText(cursorPos, varText);
                    editorRef.current.setSelection(cursorPos + varText.length);
                } else {
                    const text = form.content;
                    const newContent = text.slice(0, cursorPos) + varText + text.slice(cursorPos);
                    setForm(prev => ({ ...prev, content: newContent }));
                    // Refocus (simple workaround)
                    setTimeout(() => {
                        const ta = document.querySelector('textarea[name="content"]');
                        if (ta) ta.focus();
                    }, 0);
                }
                setAnchorEl(null);
            };

            const addRollingMessage = () => {
                if (!rollingInput.senderName || !rollingInput.content) return alert('이름과 내용을 입력해주세요.');
                setForm(prev => ({
                    ...prev,
                    messages: [...prev.messages, { ...rollingInput, id: Date.now() }]
                }));
                setRollingInput({ senderName: '', senderRole: '', content: '' });
            };

            const removeRollingMessage = (id) => {
                setForm(prev => ({ ...prev, messages: prev.messages.filter(m => m.id !== id) }));
            };

            const handleProfileChange = (e) => {
                const pid = e.target.value;
                setSelectedProfile(pid);
                const p = profiles.find(x => x.id === pid);
                if (p) {
                    setForm(prev => ({
                        ...prev,
                        senderName: p.senderName,
                        senderRole: p.senderRole,
                        phone: p.phone,
                        email: p.email,
                        theme: p.defaultTheme || 'm3_purple'
                    }));
                }
            };



            const handleSubmit = async () => {
                if (!form.subject) return alert('제목을 입력해주세요.');

                let finalUrl = '';
                let finalMultiResults = [];

                if (mode === 'general') {
                    if (!form.receiverName || !form.content) return alert('받는사람과 내용을 입력해주세요.');

                    const id = form.id || await window.LetterDB.generateID(form);
                    let finalForm = { ...form };
                    if (form.password) {
                        if (!/^\d{4,6}$/.test(form.password)) return alert('비밀번호는 4~6자리 숫자여야 합니다.');
                        const hash = await window.LetterDB.hashPassword(form.password);
                        finalForm.passwordHash = hash;
                        delete finalForm.password;
                    }

                    // Auto-Add 'inbox' tag if Sender name equals Receiver name
                    const mailbox = ['sent'];
                    if (finalForm.senderName && finalForm.receiverName && finalForm.senderName.trim() === finalForm.receiverName.trim()) {
                        mailbox.push('inbox');
                    }

                    const finalData = { ...finalForm, id, mailbox, date: new Date().toLocaleDateString() };
                    await window.LetterDB.save(finalData);
                    finalUrl = window.LetterDB.toUrl(finalData, 'view.html');

                } else if (mode === 'multi') {
                    if (!form.receivers) return alert('받는사람 목록을 입력해주세요.');
                    if (!form.content) return alert('내용을 입력해주세요.');

                    const names = form.receivers.split(',').map(n => n.trim()).filter(n => n);
                    if (names.length === 0) return alert('유효한 받는사람 이름이 없습니다.');

                    const results = [];
                    for (const name of names) {
                        // Look up role from CSV import if exists
                        const csvEntry = (window._csvReceivers || []).find(r => r.name === name);
                        const role = csvEntry ? csvEntry.role : (form.receiverRole || '');

                        const specificForm = { ...form, receiverName: name, receiverRole: role };
                        const id = await window.LetterDB.generateID(specificForm); // specific ID per receiver
                        const finalData = { ...specificForm, id, mailbox: ['sent'], date: new Date().toLocaleDateString() };
                        await window.LetterDB.save(finalData);
                        const url = window.LetterDB.toUrl(finalData, 'view.html');
                        results.push({ name, url });
                    }
                    setMultiResults(results);
                    // No Main QR for Multi
                    setResultUrl('');
                    // No Auto Shorten

                } else if (mode === 'rolling') {
                    // Check if we have PENDING CSV data
                    if (csvData && csvData.type === 'rolling' && Object.keys(csvData.groups).length > 0) {
                        const groupKeys = Object.keys(csvData.groups);
                        const newResults = [];
                        for (const key of groupKeys) {
                            const group = csvData.groups[key];
                            const rollingData = {
                                ...form, // Uses CURRENT form state (Theme, Subject, GroupName)
                                receiverName: group.name,
                                receiverRole: group.role,
                                content: form.content || `${group.msgs.length}개의 메시지`,
                                messages: JSON.stringify(group.msgs),
                                mailbox: ['sent'],
                                date: new Date().toLocaleDateString()
                            };
                            const id = await window.LetterDB.generateID(rollingData);
                            const finalData = { ...rollingData, id };
                            await window.LetterDB.save(finalData);
                            const url = window.LetterDB.toUrl(finalData, 'view.html');
                            newResults.push({ name: group.name, url });
                        }
                        setMultiResults(newResults);
                        if (newResults.length > 0) {
                            finalUrl = newResults[0].url; // Set one as primary for QR
                        }
                        setCsvData(null); // Clear pending data
                    } else {
                        // Standard Manual Rolling Paper
                        if (!form.receiverName) return alert('받는사람을 입력해주세요.');
                        if (form.messages.length === 0) return alert('메시지를 하나 이상 추가해주세요.');

                        const rollingData = {
                            ...form,
                            content: `${form.messages.length}개의 메시지가 담긴 롤링페이퍼입니다.`, // Fallback content
                            messages: JSON.stringify(form.messages)
                        };

                        const id = await window.LetterDB.generateID(rollingData);
                        const finalData = { ...rollingData, id, mailbox: ['sent'], date: new Date().toLocaleDateString() };
                        await window.LetterDB.save(finalData);
                        finalUrl = window.LetterDB.toUrl(finalData, 'view.html');
                    }
                }

                if (finalUrl) {
                    setOriginUrl(finalUrl);
                    setResultUrl('');
                    setQrFallback(false);
                    setMultiResults(finalMultiResults);

                    // Always try original first
                    generateQR(finalUrl);
                    shortenUrl(finalUrl);

                    // Clear Draft if exists in localStorage (Legacy/Backup)
                    if (form.id) {
                        localStorage.removeItem('mail2u_draft');
                    }

                    // Clear URL params (remove draftId)
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            };

            const generateRandomString = (length) => {
                const chars = 'abcdefghijklmnopqrstuvwxyz';
                let result = '';
                for (let i = 0; i < length; i++) {
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            };

            const shortenUrl = async (url, retryCount = 0) => {
                if (!url) return null;

                // Handle localhost URLs by mocking
                if (url.includes('localhost') || url.includes('127.0.0.1')) {
                    const mock = `https://is.gd/M2U${generateRandomString(4)}`;
                    setResultUrl(mock);
                    if (window._qrFailed) generateQR(mock, true);
                    return mock;
                }

                const customName = `M2U${generateRandomString(3 + retryCount)}`; // Increase length on retry

                return new Promise((resolve) => {
                    const callbackName = 'isgd_callback_' + Math.floor(Math.random() * 1000000);
                    window[callbackName] = async (data) => {
                        delete window[callbackName];
                        const script = document.getElementById(callbackName);
                        if (script) document.body.removeChild(script);

                        if (data.shorturl) {
                            setResultUrl(data.shorturl);
                            if (window._qrFailed) generateQR(data.shorturl, true);

                            // Update Form State and Save short URL back to DB record
                            if (form.id) {
                                try {
                                    setForm(prev => ({ ...prev, shortUrl: data.shorturl }));
                                    const currentLetter = await window.LetterDB.get(form.id);
                                    if (currentLetter) {
                                        await window.LetterDB.save({ ...currentLetter, shortUrl: data.shorturl });
                                    }
                                } catch (e) { console.error("Failed to save shortUrl to DB", e); }
                            }

                            resolve(data.shorturl);
                        } else if (data.errorcode === 1 && retryCount < 5) {
                            // Error code 1 usually means short URL is already taken
                            console.warn(`Short URL collision for ${customName}, retrying...`);
                            resolve(await shortenUrl(url, retryCount + 1));
                        } else {
                            console.error("Shorten Error:", data.errormessage || data.errorcode);
                            setResultUrl('FAILED');
                            resolve(null);
                        }
                    };

                    const script = document.createElement('script');
                    script.id = callbackName;
                    script.src = `https://is.gd/create.php?format=json&callback=${callbackName}&url=${encodeURIComponent(url)}&shorturl=${customName}`;
                    script.onerror = () => {
                        delete window[callbackName];
                        if (script.parentNode) document.body.removeChild(script);
                        setResultUrl('FAILED');
                        resolve(null);
                    };
                    document.body.appendChild(script);

                    // Timeout handling
                    setTimeout(() => {
                        if (window[callbackName]) {
                            delete window[callbackName];
                            if (script.parentNode) document.body.removeChild(script);
                            setResultUrl('FAILED');
                            resolve(null);
                        }
                    }, 8000);
                });
            };

            const generateQR = (url, isFallback = false) => {
                if (!url) return;
                setTimeout(() => {
                    if (qrRef.current) {
                        QRCode.toCanvas(qrRef.current, url, { width: 220, margin: 2 }, (err) => {
                            if (err) {
                                console.warn("QR Generation error:", err);
                                window._qrFailed = true;
                                if (!isFallback) {
                                    // If we already have resultUrl (short), try it
                                    if (resultUrl && resultUrl !== 'FAILED') {
                                        generateQR(resultUrl, true);
                                    }
                                } else {
                                    setQrFallback(true);
                                }
                            } else {
                                window._qrFailed = false;
                                setQrFallback(isFallback);
                            }
                        });
                    }
                }, 100);
            };

            const copyToClipboard = async (text) => {
                try {
                    await navigator.clipboard.writeText(text);
                    setSnackbar({ open: true, message: '링크가 복사되었습니다.' });
                } catch (err) {
                    console.error('Failed to copy: ', err);
                    setSnackbar({ open: true, message: '복사 실패' });
                }
            };

            // CSV Logic
            const handleCsvUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (evt) => {
                    const text = evt.target.result;
                    processCSV(text);
                };
                reader.readAsText(file);
            };

            const processCSV = async (text) => {
                const lines = text.split('\n').map(l => l.trim()).filter(l => l);

                if (mode === 'multi') {
                    const newReceivers = [];
                    const receiversWithRoles = []; // Store name and role pairs

                    for (const line of lines) {
                        const parts = line.split(',');
                        const name = parts[0]?.trim();
                        const role = parts[1]?.trim() || '';
                        if (name) {
                            newReceivers.push(name);
                            receiversWithRoles.push({ name, role });
                        }
                    }

                    // Store the role-mapped receivers for the submission logic
                    window._csvReceivers = receiversWithRoles;
                    setForm(prev => ({ ...prev, receivers: newReceivers.join(', ') }));
                    alert(`${newReceivers.length}명의 수신자를 불러왔습니다. 내용 작성 후 전송을 눌러주세요.`);
                } else if (mode === 'rolling') {
                    // Start Smart Grouping Logic
                    // Format: [ReceiverName, ReceiverRole, SenderName, SenderRole, Content]

                    const newMessages = [];
                    const groups = {}; // For Batch Mode

                    lines.forEach(line => {
                        // Use regex to split by comma but ignore commas inside quotes
                        // This handles cases where content might have commas "Hello, world"
                        const parts = line.match(/(".*?"|[^",\s]+)(?=\s*,|\s*$)/g) || line.split(',');
                        // Clean quotes from parts if regex was used
                        const cleanParts = parts.map(p => p.trim().replace(/^"(.*)"$/, '$1').trim());

                        // Simple heuristic: Count non-empty parts
                        // But split(',') naive approach:
                        const naiveParts = line.split(',');

                        // Check Column Count to distinguish modes
                        // Case A: Batch Mode -> Receiver, RecRole, Sender, SenRole, Content (5 items expected)
                        // Heuristic: If we have at least 4 commas, it's likely Batch Mode.
                        // OR check if Parts length >= 5.
                        // Problem: "Sender, Role, Content which has commas" -> split gives > 3 parts.

                        // Better Heuristic: Check if line starts with 5 distinct fields?
                        // Let's assume Batch Mode MUST have 5 fields.
                        // Message Mode has 2 or 3.

                        // Let's rely on the Sample CSV format strictly.
                        // Rolling Sample: Name, Role, Name, Role, Content
                        // Message Sample: Name, Role, Content

                        // Conflict: A, B, C can be Message Mode (Sender, Role, Content).
                        // Conflict: A, B, C, D, E can be Batch Mode.

                        // What if Content in Message Mode has 2 commas? A, B, "C, D, E"
                        // Naive split gives 5 parts.
                        // So naive split is bad.

                        // Let's use a smarter split for CSV
                        let row = [];
                        let current = '';
                        let inQuote = false;
                        for (let i = 0; i < line.length; i++) {
                            const char = line[i];
                            if (char === '"') { inQuote = !inQuote; }
                            else if (char === ',' && !inQuote) {
                                row.push(current.trim());
                                current = '';
                            }
                            else { current += char; }
                        }
                        row.push(current.trim());

                        if (row.length >= 5) {
                            const [recName, recRole, sendName, sendRole, ...contentParts] = row;
                            const content = contentParts.join(',').trim();

                            // Grouping Logic
                            let key = recName.trim().replace(/[^가-힣a-zA-Z0-9]/g, '');
                            if (/[가-힣]/.test(key)) key = key.replace(/[a-zA-Z]/g, '');

                            if (!groups[key]) {
                                groups[key] = { name: recName.trim(), role: recRole.trim(), msgs: [] };
                            }
                            groups[key].msgs.push({
                                senderName: sendName.trim(),
                                senderRole: sendRole.trim(),
                                content: content,
                                id: Date.now() + Math.random()
                            });
                        }
                        else if (row.length >= 2) {
                            let senderName, senderRole, content;

                            if (row.length >= 3) {
                                // Sender, Role, Content
                                const [sName, sRole, ...cParts] = row;
                                senderName = sName;
                                senderRole = sRole;
                                content = cParts.join(',').trim();
                            } else {
                                // Sender, Content
                                senderName = row[0];
                                content = row.slice(1).join(',').trim();
                                senderRole = '';
                            }

                            if (senderName && content) {
                                newMessages.push({
                                    senderName: senderName.trim(),
                                    senderRole: senderRole ? senderRole.trim() : '',
                                    content: content,
                                    id: Date.now() + Math.random()
                                });
                            }
                        }
                    });

                    // Decide Action based on what we found
                    const groupKeys = Object.keys(groups);

                    if (groupKeys.length > 0) {
                        // Batch Mode found
                        setCsvData({ type: 'rolling', groups, count: groupKeys.length });
                        alert(`${groupKeys.length}개의 롤링페이퍼 그룹을 불러왔습니다.\\n제목, 테마, 그룹명을 설정한 후 '보내기'를 눌러주세요.`);
                    } else if (newMessages.length > 0) {
                        // Message Import Mode found
                        setForm(prev => ({
                            ...prev,
                            messages: [...prev.messages, ...newMessages]
                        }));
                        alert(`${newMessages.length}개의 메시지가 작성 목록에 추가되었습니다.`);
                    } else {
                        alert('유효한 CSV 데이터가 없습니다.');
                    }
                }
            };

            // Variable Guide Dialog
            const [openVarGuide, setOpenVarGuide] = useState(false);
            const [guideTab, setGuideTab] = useState(0);

            return (
                <ThemeProvider theme={theme}>
                    <CssBaseline />

                    <AppBar position="sticky" sx={{ px: { xs: 0, md: 2 } }}>
                        <Toolbar>
                            <IconButton edge="start" onClick={() => window.location.href = 'index.html'} sx={{ mr: 1, color: 'onSurface' }}>
                                <span className="material-symbols-rounded">arrow_back</span>
                            </IconButton>
                            <Stack direction="row" spacing={1} alignItems="center">
                                <Typography variant="h6" sx={{ flex: 1, color: 'var(--md-sys-color-on-surface)', fontWeight: 600 }}>
                                    새 편지 {form.id && <Chip label={form.id} size="small" sx={{ ml: 1, bgcolor: 'primary.container', color: 'onPrimaryContainer' }} />}
                                </Typography>
                                <Button onClick={handleSubmit} variant="contained" disableElevation sx={{ borderRadius: 20, px: 3 }}>
                                    보내기
                                </Button>
                            </Stack>
                        </Toolbar>
                    </AppBar>

                    <Container maxWidth="md" sx={{ py: 4 }}>
                        <Paper sx={{ p: 4, bgcolor: 'var(--T_surfaceContainer)' }}>
                            <Tabs value={mode} onChange={(e, v) => setMode(v)} sx={{ mb: 3 }} variant="fullWidth">
                                <Tab label="일반 편지" value="general" />
                                <Tab label="다수 발송" value="multi" />
                                <Tab label="롤링페이퍼" value="rolling" />
                            </Tabs>

                            <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 2, gap: 1 }}>
                                <Button size="small" variant="text" startIcon={<span className="material-symbols-rounded">help</span>} onClick={() => setOpenVarGuide(true)}>
                                    변수 도움말
                                </Button>
                                <Box sx={{ textAlign: 'right' }}>
                                    <Button component="label" size="small" variant="outlined" startIcon={<span className="material-symbols-rounded">upload_file</span>}>
                                        CSV 업로드
                                        <input type="file" accept=".csv" hidden onChange={handleCsvUpload} />
                                    </Button>
                                    <Typography variant="caption" display="block" color="text.secondary" sx={{ mt: 0.5 }}>
                                        ※ 업로드 전 <strong>테마, 제목, 그룹명</strong>을 먼저 설정해주세요.
                                    </Typography>
                                </Box>
                            </Box>

                            <Stack spacing={3}>
                                <Box>
                                    <Typography variant="body2" color="textSecondary" gutterBottom sx={{ fontWeight: 500, mb: 1 }}>
                                        테마 색상
                                    </Typography>
                                    <Stack direction="row" spacing={1} sx={{ overflowX: 'auto', pb: 1, '&::-webkit-scrollbar': { display: 'none' } }}>
                                        {THEMES.map(t => (
                                            <Chip
                                                key={t.id}
                                                label={t.name}
                                                onClick={() => setForm({ ...form, theme: t.id })}
                                                variant={form.theme === t.id ? "filled" : "outlined"}
                                                color={form.theme === t.id ? 'primary' : 'default'}
                                                icon={form.theme === t.id ? <span className="material-symbols-rounded" style={{ fontSize: 18 }}>check</span> : null}
                                                sx={{
                                                    height: 36,
                                                    px: 1,
                                                    borderRadius: 10,
                                                    fontWeight: 600,
                                                    bgcolor: form.theme === t.id ? 'primary.main' : 'transparent',
                                                    color: form.theme === t.id ? 'white' : 'onSurfaceVariant',
                                                    '&:hover': { bgcolor: form.theme === t.id ? 'primary.main' : 'var(--T_surfaceContainer)' }
                                                }}
                                            />
                                        ))}
                                    </Stack>
                                </Box>

                                <Stack direction="row" spacing={2} alignItems="center" justifyContent="space-between">
                                    <Typography variant="h5" color="primary" sx={{ fontWeight: 400 }}>편지 내용</Typography>
                                    <ToggleButtonGroup
                                        value={form.contentType}
                                        exclusive
                                        onChange={(e, newType) => newType && setForm({ ...form, contentType: newType })}
                                        size="small"
                                        aria-label="content type"
                                        sx={{ height: 32 }}
                                    >
                                        <ToggleButton value="text">Text</ToggleButton>
                                        <ToggleButton value="markdown">MD</ToggleButton>
                                        <ToggleButton value="html">HTML</ToggleButton>
                                    </ToggleButtonGroup>
                                </Stack>

                                <TextField label="제목" name="subject" value={form.subject} onChange={handleChange} required placeholder="제목을 입력하세요" />

                                {mode !== 'multi' && (
                                    <Stack direction={{ xs: 'column', sm: 'row' }} spacing={2}>
                                        <TextField label="받는사람 (이름)" name="receiverName" value={form.receiverName} onChange={handleChange} required />
                                        <TextField label="받는사람 (직함/역할)" name="receiverRole" value={form.receiverRole} onChange={handleChange} />
                                    </Stack>
                                )}

                                {mode === 'multi' && (
                                    <TextField
                                        label="받는사람 목록 (콤마 , 로 구분)"
                                        name="receivers"
                                        value={form.receivers}
                                        onChange={handleChange}
                                        required
                                        placeholder="예: 철수, 영희, 민수"
                                        helperText="여러 명에게 각각 다른 링크의 편지를 보냅니다."
                                    />
                                )}

                                {mode !== 'rolling' ? (
                                    <Stack spacing={2}>
                                        <Stack direction={{ xs: 'column', sm: 'row' }} spacing={2} alignItems="center">
                                            <TextField label="보낸사람 (이름)" name="senderName" value={form.senderName} onChange={handleChange} sx={{ flex: 1 }} />
                                            <TextField label="보낸사람 (직함/역할)" name="senderRole" value={form.senderRole} onChange={handleChange} sx={{ flex: 1 }} />
                                            {profiles.length > 0 && (
                                                <FormControl size="small" sx={{ minWidth: 120 }}>
                                                    <InputLabel>프로필</InputLabel>
                                                    <Select value={selectedProfile} label="프로필" onChange={handleProfileChange}>
                                                        <MenuItem value="">직접 입력</MenuItem>
                                                        {profiles.map(p => <MenuItem key={p.id} value={p.id}>{p.name}</MenuItem>)}
                                                    </Select>
                                                </FormControl>
                                            )}
                                        </Stack>
                                    </Stack>
                                ) : (
                                    <TextField
                                        label="보내는 그룹명 (예: 1학년 45반 학생들)"
                                        name="senderName"
                                        value={form.senderName}
                                        onChange={handleChange}
                                        placeholder="편지 하단 '보낸이' 자리에 표시됩니다."
                                    />
                                )}

                                {mode !== 'rolling' && (
                                    <>
                                        {form.contentType === 'html' ? (
                                            <Box sx={{ bgcolor: 'background.paper', borderRadius: 2, overflow: 'hidden' }}>
                                                <div id="editor" style={{ height: 300, backgroundColor: 'white' }}></div>
                                            </Box>
                                        ) : (
                                            <TextField
                                                label={`내용 (${form.contentType})`} name="content"
                                                multiline rows={8}
                                                value={form.content} onChange={handleChange}
                                                placeholder={form.contentType === 'markdown' ? '# Markdown 내용을 입력하세요' : '전하고 싶은 말을 적어보세요... Tip: /{ 를 입력하여 변수를 사용해보세요.'}
                                                required
                                                onSelect={(e) => {
                                                    // Track cursor for precise insertion if needed
                                                }}
                                            />
                                        )}
                                        <Menu
                                            anchorEl={anchorEl}
                                            open={Boolean(anchorEl)}
                                            onClose={() => setAnchorEl(null)}
                                        >
                                            <MenuItem disabled><Typography variant="caption">변수 선택</Typography></MenuItem>
                                            <Divider />
                                            {['name', 'role', 'sender', 'Device', 'OS', 'Browser', 'Resolution', 'DarkMode', 'IP', 'Weather', 'year', 'month', 'day', 'weekday', 'time', 'ampm', 'Rand', 'Coin', 'Dice', 'Mob:', 'Des:'].map(v => (
                                                <MenuItem key={v} onClick={() => handleVarSelect(v)}>{v}{!v.endsWith(':') && '}'}</MenuItem>
                                            ))}
                                        </Menu>
                                    </>
                                )}

                                {mode === 'rolling' && (
                                    <Box sx={{ bgcolor: 'var(--T_surfaceContainer)', p: 2, borderRadius: 2 }}>
                                        <Typography variant="subtitle2" sx={{ mb: 1 }}>메시지 작성 ({form.messages.length}개)</Typography>

                                        {/* CSV Loaded Indicator */}
                                        {csvData && csvData.type === 'rolling' && (
                                            <Paper sx={{ p: 2, mb: 2, bgcolor: 'primary.container', color: 'onPrimaryContainer' }}>
                                                <Typography variant="subtitle2" sx={{ fontWeight: 700 }}>CSV 데이터 대기 중</Typography>
                                                <Typography variant="body2">{csvData.count}개의 롤링페이퍼 그룹이 전송을 기다리고 있습니다.</Typography>
                                                <Typography variant="caption">제목, 테마, 그룹명을 설정한 후 '보내기'를 누르면 일괄 생성됩니다.</Typography>
                                                <Button size="small" color="inherit" onClick={() => setCsvData(null)} sx={{ mt: 1 }}>CSV 취소</Button>
                                            </Paper>
                                        )}

                                        <Stack spacing={2} sx={{ mb: 2 }}>
                                            {form.messages.map((m, i) => (
                                                <Paper key={m.id || i} sx={{ p: 1.5, display: 'flex', alignItems: 'center' }}>
                                                    <Box sx={{ flexGrow: 1 }}>
                                                        <Typography variant="subtitle2">{m.senderName} <Typography component="span" variant="caption" color="text.secondary">{m.senderRole}</Typography></Typography>
                                                        <Typography variant="body2" noWrap>{m.content}</Typography>
                                                    </Box>
                                                    <IconButton size="small" onClick={() => removeRollingMessage(m.id)}><span className="material-symbols-rounded">close</span></IconButton>
                                                </Paper>
                                            ))}
                                        </Stack>
                                        <Stack spacing={2}>
                                            <Stack direction="row" spacing={1}>
                                                <TextField size="small" label="작성자 이름" value={rollingInput.senderName} onChange={e => setRollingInput({ ...rollingInput, senderName: e.target.value })} sx={{ flex: 1 }} />
                                                <TextField size="small" label="역할(선택)" value={rollingInput.senderRole} onChange={e => setRollingInput({ ...rollingInput, senderRole: e.target.value })} sx={{ flex: 1 }} />
                                            </Stack>
                                            <TextField size="small" label="내용" multiline rows={2} value={rollingInput.content} onChange={e => setRollingInput({ ...rollingInput, content: e.target.value })} />
                                            <Button variant="outlined" onClick={addRollingMessage} startIcon={<span className="material-symbols-rounded">add</span>}>메시지 추가</Button>
                                        </Stack>
                                    </Box>
                                )}

                                <Typography variant="h5" color="secondary" sx={{ mb: 1, mt: 4, fontWeight: 400 }}>추가 정보</Typography>

                                <Stack direction={{ xs: 'column', sm: 'row' }} spacing={2}>
                                    <TextField label="전화번호 (선택)" name="phone" value={form.phone} onChange={handleChange} placeholder="예: 010-1234-5678" />
                                    <TextField label="이메일 (선택)" name="email" value={form.email} onChange={handleChange} placeholder="예: user@example.com" />
                                </Stack>
                                <Stack direction={{ xs: 'column', sm: 'row' }} spacing={2}>
                                    <TextField label="첨부파일 링크 (URL)" name="driveLink" value={form.driveLink} onChange={handleChange} placeholder="https://" sx={{ flex: 1 }} />
                                    <TextField label="비밀번호 설정 (4~6자리 숫자)" name="password" value={form.password || ''} onChange={handleChange} placeholder="입력 시 잠금 적용" inputProps={{ maxLength: 6, pattern: "[0-9]*" }} sx={{ width: { sm: 200 } }} />
                                </Stack>

                            </Stack>
                        </Paper>
                    </Container>

                    {/* Result Dialog */}
                    <Dialog open={!!originUrl} onClose={() => { setResultUrl(''); setOriginUrl(''); }} maxWidth="xs" fullWidth>
                        <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'center', p: 4 }}>
                            <span className="material-symbols-rounded" style={{ fontSize: 56, color: THEMES.find(t => t.id === form.theme)?.color || '#6750A4', marginBottom: 16 }}>check_circle</span>
                            <DialogTitle sx={{ p: 0, mb: 1, fontWeight: 700 }}>작성 완료!</DialogTitle>
                            <Typography variant="body2" color="text.secondary" align="center" sx={{ mb: 4 }}>
                                QR 코드를 스캔하거나 링크를 복사하세요.
                            </Typography>

                            <Box sx={{ p: 2, bgcolor: 'white', borderRadius: 4, border: '1px solid #E0E0E0', mb: 4, display: 'flex', justifyContent: 'center' }}>
                                <canvas ref={qrRef} />
                            </Box>

                            <Stack spacing={2} sx={{ width: '100%', mb: 4 }}>
                                <Button
                                    fullWidth
                                    variant="outlined"
                                    color="secondary"
                                    startIcon={<span className="material-symbols-rounded">link</span>}
                                    sx={{ height: 48, borderRadius: 12 }}
                                    onClick={() => { navigator.clipboard.writeText(originUrl); alert('원본 링크가 복사되었습니다.'); }}
                                >
                                    원본 링크 복사
                                </Button>

                                {resultUrl ? (
                                    resultUrl !== 'FAILED' ? (
                                        <Button
                                            fullWidth
                                            variant="contained"
                                            color="primary"
                                            startIcon={<span className="material-symbols-rounded">content_copy</span>}
                                            sx={{ height: 48, borderRadius: 12, fontWeight: 700 }}
                                            onClick={() => { navigator.clipboard.writeText(resultUrl); alert('단축 링크가 복사되었습니다.'); }}
                                        >
                                            단축 링크 복사
                                        </Button>
                                    ) : (
                                        <Typography variant="caption" color="error" align="center">단축 링크 생성에 실패했습니다.</Typography>
                                    )
                                ) : (
                                    <Button
                                        fullWidth
                                        disabled
                                        variant="contained"
                                        sx={{ height: 48, borderRadius: 12, opacity: 0.7 }}
                                    >
                                        <CircularProgress size={20} sx={{ mr: 1 }} color="inherit" />
                                        단축 링크 생성 중...
                                    </Button>
                                )}

                                {qrFallback && (
                                    <Typography variant="caption" color="error" align="center" sx={{ display: 'block', mt: 1, fontWeight: 700 }}>
                                        원본 주소가 너무 길어 단축 주소로 QR코드를 생성했습니다.
                                    </Typography>
                                )}
                            </Stack>

                            {multiResults.length > 0 && (
                                <Box sx={{ width: '100%', mb: 4 }}>
                                    <Divider sx={{ mb: 2 }} />
                                    <Typography variant="subtitle2" gutterBottom sx={{ fontWeight: 700 }}>개별 링크 목록 ({multiResults.length}명)</Typography>
                                    <List dense sx={{ maxHeight: 200, overflow: 'auto', bgcolor: 'rgba(0,0,0,0.03)', borderRadius: 3, border: '1px solid #eee' }}>
                                        {multiResults.map((res, i) => (
                                            <ListItem key={i} secondaryAction={
                                                <IconButton edge="end" size="small" onClick={() => { navigator.clipboard.writeText(res.url); alert(`${res.name}님 링크 복사됨`); }}>
                                                    <span className="material-symbols-rounded" style={{ fontSize: 20 }}>content_copy</span>
                                                </IconButton>
                                            }>
                                                <ListItemText
                                                    primary={<Typography variant="body2" sx={{ fontWeight: 600 }}>{res.name}</Typography>}
                                                    secondary={<Typography variant="caption" sx={{ wordBreak: 'break-all', opacity: 0.6 }}>{res.url.slice(0, 35)}...</Typography>}
                                                />
                                            </ListItem>
                                        ))}
                                    </List>
                                    <Button fullWidth variant="outlined" startIcon={<span className="material-symbols-rounded">download</span>} sx={{ mt: 1.5, borderRadius: 12 }} onClick={() => {
                                        const csvContent = "이름,URL\n" + multiResults.map(r => `${r.name},${r.url}`).join("\n");
                                        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                                        const link = document.createElement("a");
                                        link.href = URL.createObjectURL(blob);
                                        link.download = "mail2u_results.csv";
                                        link.click();
                                    }}>
                                        결과 CSV 다운로드
                                    </Button>
                                </Box>
                            )}

                            <Button onClick={() => { setResultUrl(''); setOriginUrl(''); }} fullWidth color="secondary" variant="outlined" sx={{ borderRadius: 24 }}>닫기</Button>
                        </Box>
                    </Dialog>
                    <Dialog open={openVarGuide} onClose={() => setOpenVarGuide(false)} maxWidth="md" fullWidth PaperProps={{ sx: { borderRadius: 7, maxWidth: '800px' } }}>
                        <DialogTitle sx={{ bgcolor: 'primary.main', color: 'white', display: 'flex', alignItems: 'center', gap: 1 }}>
                            <span className="material-symbols-rounded">help</span>
                            사용자 가이드
                        </DialogTitle>
                        <Box sx={{ borderBottom: 1, borderColor: 'divider', bgcolor: 'primary.container', px: 1 }}>
                            <Tabs value={guideTab} onChange={(e, v) => setGuideTab(v)} textColor="primary" indicatorColor="primary">
                                <Tab label="고급 변수" />
                                <Tab label="CSV 업로드" />
                            </Tabs>
                        </Box>
                        <DialogContent dividers sx={{ p: 3, bgcolor: 'var(--T_surface)' }}>
                            {guideTab === 0 && (
                                <Box>
                                    <Typography variant="body2" paragraph sx={{ bgcolor: 'primary.container', color: 'onPrimaryContainer', p: 2, borderRadius: 3, border: '1px solid', borderColor: 'primary.main' }}>
                                        <Stack direction="row" spacing={1} alignItems="center">
                                            <span className="material-symbols-rounded" style={{ fontSize: 20 }}>info</span>
                                            <strong>Syntax:</strong>
                                        </Stack>
                                        이제 모든 모드(Text, MD, HTML)에서 변수는 <code>/{'{'}Variable{'}'}</code> 형태로 사용합니다.<br />
                                        입력창에서 <code>/{'{'}</code>를 타이핑하면 자동완성 메뉴가 나타납니다.
                                    </Typography>

                                    <Typography variant="subtitle2" gutterBottom sx={{ mt: 2 }}>1. 기본 정보 (수신자/발신자)</Typography>
                                    <TableContainer component={Paper} variant="outlined" sx={{ mb: 2, overflowX: 'auto', borderRadius: 3, border: '1px solid', borderColor: 'divider', bgcolor: '#FFFFFF' }}>
                                        <Table size="small">
                                            <TableHead><TableRow sx={{ bgcolor: 'secondary.container' }}><TableCell sx={{ fontWeight: 700, color: 'secondary.onContainer' }}>변수명</TableCell><TableCell sx={{ fontWeight: 700, color: 'secondary.onContainer' }}>설명</TableCell><TableCell sx={{ fontWeight: 700, color: 'secondary.onContainer' }}>예시 출력</TableCell></TableRow></TableHead>
                                            <TableBody>
                                                <TableRow><TableCell><code>/&#123;name&#125;</code></TableCell><TableCell>받는사람 이름</TableCell><TableCell>홍길동</TableCell></TableRow>
                                                <TableRow><TableCell><code>/&#123;role&#125;</code></TableCell><TableCell>받는사람 역할</TableCell><TableCell>부장님</TableCell></TableRow>
                                                <TableRow><TableCell><code>/&#123;sender&#125;</code></TableCell><TableCell>보낸사람 이름</TableCell><TableCell>김철수</TableCell></TableRow>
                                            </TableBody>
                                        </Table>
                                    </TableContainer>

                                    <Typography variant="subtitle2" gutterBottom sx={{ mt: 2 }}>2. 기기 및 환경 (조회 시점 기준)</Typography>
                                    <TableContainer component={Paper} variant="outlined" sx={{ mb: 2, overflowX: 'auto', borderRadius: 3, border: '1px solid', borderColor: 'divider', bgcolor: '#FFFFFF' }}>
                                        <Table size="small">
                                            <TableHead><TableRow sx={{ bgcolor: 'secondary.container' }}><TableCell sx={{ fontWeight: 700, color: 'secondary.onContainer' }}>변수명</TableCell><TableCell sx={{ fontWeight: 700, color: 'secondary.onContainer' }}>설명</TableCell><TableCell sx={{ fontWeight: 700, color: 'secondary.onContainer' }}>예시 출력</TableCell></TableRow></TableHead>
                                            <TableBody>
                                                <TableRow><TableCell><code>/&#123;Device&#125;</code></TableCell><TableCell>접속 기기</TableCell><TableCell>Mobile / Desktop</TableCell></TableRow>
                                                <TableRow><TableCell><code>/&#123;OS&#125;</code></TableCell><TableCell>운영체제</TableCell><TableCell>Windows, iOS, Android...</TableCell></TableRow>
                                                <TableRow><TableCell><code>/&#123;Browser&#125;</code></TableCell><TableCell>브라우저</TableCell><TableCell>Chrome, Safari...</TableCell></TableRow>
                                                <TableRow><TableCell><code>/&#123;Resolution&#125;</code></TableCell><TableCell>화면 해상도</TableCell><TableCell>FHD Landscape</TableCell></TableRow>
                                                <TableRow><TableCell><code>/&#123;DarkMode&#125;</code></TableCell><TableCell>다크모드 여부</TableCell><TableCell>Dark / Light</TableCell></TableRow>
                                                <TableRow><TableCell><code>/&#123;IP&#125;</code></TableCell><TableCell>접속 IP</TableCell><TableCell>123.45.67.89</TableCell></TableRow>
                                                <TableRow><TableCell><code>/&#123;Weather&#125;</code></TableCell><TableCell>날씨 (오픈API)</TableCell><TableCell>맑음, 24°C</TableCell></TableRow>
                                            </TableBody>
                                        </Table>
                                    </TableContainer>

                                    <Typography variant="subtitle2" gutterBottom sx={{ mt: 2 }}>3. 날짜 및 시간</Typography>
                                    <TableContainer component={Paper} variant="outlined" sx={{ mb: 2, overflowX: 'auto', borderRadius: 3, border: '1px solid', borderColor: 'divider', bgcolor: '#FFFFFF' }}>
                                        <Table size="small">
                                            <TableHead><TableRow sx={{ bgcolor: 'secondary.container' }}><TableCell sx={{ fontWeight: 700, color: 'secondary.onContainer' }}>변수명</TableCell><TableCell sx={{ fontWeight: 700, color: 'secondary.onContainer' }}>설명</TableCell><TableCell sx={{ fontWeight: 700, color: 'secondary.onContainer' }}>예시</TableCell></TableRow></TableHead>
                                            <TableBody>
                                                <TableRow><TableCell><code>/&#123;year&#125;</code>, <code>/&#123;month&#125;</code>, <code>/&#123;day&#125;</code></TableCell><TableCell>년/월/일</TableCell><TableCell>2024, 1, 24</TableCell></TableRow>
                                                <TableRow><TableCell><code>/&#123;weekday&#125;</code></TableCell><TableCell>요일</TableCell><TableCell>토</TableCell></TableRow>
                                                <TableRow><TableCell><code>/&#123;time&#125;</code>, <code>/&#123;ampm&#125;</code></TableCell><TableCell>시간, 오전/오후</TableCell><TableCell>21:05, 오후</TableCell></TableRow>
                                            </TableBody>
                                        </Table>
                                    </TableContainer>

                                    <Typography variant="subtitle2" gutterBottom sx={{ mt: 2 }}>4. 랜덤 및 특수 기능</Typography>
                                    <TableContainer component={Paper} variant="outlined" sx={{ mb: 2, overflowX: 'auto', borderRadius: 3, border: '1px solid', borderColor: 'divider', bgcolor: '#FFFFFF' }}>
                                        <Table size="small">
                                            <TableHead><TableRow sx={{ bgcolor: 'secondary.container' }}><TableCell sx={{ fontWeight: 700, color: 'secondary.onContainer' }}>변수명</TableCell><TableCell sx={{ fontWeight: 700, color: 'secondary.onContainer' }}>설명</TableCell><TableCell sx={{ fontWeight: 700, color: 'secondary.onContainer' }}>출력 형태</TableCell></TableRow></TableHead>
                                            <TableBody>
                                                <TableRow><TableCell><code>/&#123;Rand&#125;</code></TableCell><TableCell>1~100 랜덤 숫자</TableCell><TableCell>42</TableCell></TableRow>
                                                <TableRow><TableCell><code>/&#123;Rand:1-10&#125;</code></TableCell><TableCell>지정 범위 랜덤 숫자</TableCell><TableCell>7</TableCell></TableRow>
                                                <TableRow><TableCell><code>/&#123;Coin&#125;</code>, <code>/&#123;Dice&#125;</code></TableCell><TableCell>동전 / 주사위</TableCell><TableCell>앞면 / 6</TableCell></TableRow>
                                            </TableBody>
                                        </Table>
                                    </TableContainer>

                                    <Typography variant="subtitle2" gutterBottom sx={{ mt: 2 }}>5. 스마트 조건부 메시지</Typography>
                                    <TableContainer component={Paper} variant="outlined" sx={{ mb: 2, overflowX: 'auto', borderRadius: 3, border: '1px solid', borderColor: 'divider', bgcolor: '#FFFFFF' }}>
                                        <Table size="small">
                                            <TableHead><TableRow sx={{ bgcolor: 'secondary.container' }}><TableCell sx={{ fontWeight: 700, color: 'secondary.onContainer' }}>변수명</TableCell><TableCell sx={{ fontWeight: 700, color: 'secondary.onContainer' }}>조건</TableCell><TableCell sx={{ fontWeight: 700, color: 'secondary.onContainer' }}>설명</TableCell></TableRow></TableHead>
                                            <TableBody>
                                                <TableRow><TableCell><code>/&#123;Mob:내용&#125;</code></TableCell><TableCell>모바일 접속 시</TableCell><TableCell>'내용' 출력</TableCell></TableRow>
                                                <TableRow><TableCell><code>/&#123;Des:내용&#125;</code></TableCell><TableCell>PC 접속 시</TableCell><TableCell>'내용' 출력</TableCell></TableRow>
                                                <TableRow><TableCell><code>/&#123;IOS:내용&#125;</code></TableCell><TableCell>아이폰 접속 시</TableCell><TableCell>기타 OS(ANDROID 등)도 가능</TableCell></TableRow>
                                                <TableRow><TableCell><code>/&#123;Device=Mobile=폰&#125;</code></TableCell><TableCell>직접 비교</TableCell><TableCell>/&#123;Key=Value=Text&#125; 형태</TableCell></TableRow>
                                            </TableBody>
                                        </Table>
                                    </TableContainer>
                                </Box>
                            )}
                            {guideTab === 1 && (
                                <Box>
                                    <Typography variant="subtitle1" gutterBottom>CSV 파일 규칙</Typography>
                                    <Typography variant="body2" component="div" sx={{ bgcolor: 'surfaceVariant.main', color: 'surfaceVariant.onMain', p: 3, borderRadius: 4, mt: 2, border: '1px solid rgba(0,0,0,0.05)' }}>
                                        <Typography variant="subtitle2" gutterBottom sx={{ fontWeight: 700, color: 'primary.main' }}>1. 다수 발송 모드 CSV (Name, Role)</Typography>
                                        <Box sx={{ bgcolor: 'white', p: 1.5, borderRadius: 2, mb: 2, fontFamily: 'monospace', fontSize: '0.85rem' }}>
                                            홍길동, 대리<br />
                                            김철수, 과장<br />
                                            이영희, 팀장
                                        </Box>
                                        <Typography variant="subtitle2" gutterBottom sx={{ fontWeight: 700, color: 'primary.main' }}>2. 롤링페이퍼 모드 CSV (Receiver, Rec-Role, Sender, Sen-Role, Content)</Typography>
                                        <Box sx={{ bgcolor: 'white', p: 1.5, borderRadius: 2, fontFamily: 'monospace', fontSize: '0.85rem' }}>
                                            홍길동, 대리, 이영희, 팀장, 생일 축하해요!<br />
                                            홍길동, 대리, 박지성, 사원, 늘 감사합니다.<br />
                                            김철수, 과장, 이영희, 팀장, 수고하셨습니다.
                                        </Box>
                                        <Typography variant="caption" display="block" sx={{ mt: 2, color: 'text.secondary' }}>
                                            ※ 받는 사람(Receiver)이 같으면 자동으로 하나의 롤링페이퍼로 그룹화됩니다.
                                        </Typography>
                                    </Typography>
                                </Box>
                            )}
                        </DialogContent>
                        <DialogActions>
                            <Button onClick={() => setOpenVarGuide(false)}>닫기</Button>
                        </DialogActions>
                    </Dialog>
                </ThemeProvider >
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>