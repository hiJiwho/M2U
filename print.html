<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mail 2 U - Print Cards</title>
    <!-- Fonts & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" />
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@24,400,0,0" />

    <!-- Dependencies -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/@mui/material@5.16.1/umd/material-ui.development.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
    <script src="./db.js"></script>

    <style>
        @page {
            size: A4;
            margin: 0;
        }

        body {
            margin: 0;
            padding: 0;
            background: #EEE;
        }

        .page {
            width: 210mm;
            height: 297mm;
            background: white;
            margin: 20px auto;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        @media print {
            body {
                background: white;
                -webkit-print-color-adjust: exact;
                print-color-adjust: exact;
            }

            .page {
                margin: 0;
                box-shadow: none;
                page-break-after: always;
            }

            .no-print {
                display: none !important;
            }
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const { Box, Typography, Button, Paper, ToggleButton, ToggleButtonGroup, Checkbox, FormControlLabel, AppBar, Toolbar } = MaterialUI;

        // A4 Specs (mm)
        const A4_W = 210;
        const A4_H = 297;

        // Card Styles
        const CardFront = ({ data, width, height, bwMode }) => {
            const themeColor = {
                m3_purple: '#6750A4',
                mint: '#008272',
                berry: '#0067C0',
                candy: '#E3008C',
                forest: '#004E4C',
                pumpkin: '#D83B01',
                zinc: '#505050'
            }[data.theme] || '#6750A4';

            const outerStyle = bwMode ? {
                border: '1px dashed #000', background: 'white'
            } : {
                border: '1px dashed #CCC', background: 'white'
            };

            const innerStyle = bwMode ? {
                border: '2px solid black', background: 'white', color: 'black'
            } : {
                border: `2px solid ${themeColor}`, background: '#FAF8FD', color: '#1D1B20'
            };

            const iconStyle = bwMode ? { color: 'black', marginBottom: 16 } : { color: themeColor, marginBottom: 16 };

            return (
                <div style={{
                    width: '100%', height: '100%', boxSizing: 'border-box',
                    display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
                    padding: '10%', position: 'relative',
                    ...outerStyle
                }}>
                    <div style={{
                        width: '100%', height: '100%', borderRadius: 16,
                        display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
                        ...innerStyle
                    }}>
                        <span className="material-symbols-rounded" style={{ fontSize: 48, ...iconStyle }}>mail</span>
                        <Typography variant="h6" style={{ fontWeight: 600 }}>{data.receiverName}</Typography>
                        <Typography variant="caption" style={{ opacity: 0.7 }}>{data.receiverRole || 'To You'}</Typography>
                    </div>
                </div>
            );
        };

        const CardBack = ({ data, width, height, qrUrl, bwMode }) => {
            const themeColor = {
                m3_purple: '#6750A4',
                mint: '#008272',
                berry: '#0067C0',
                candy: '#E3008C',
                forest: '#004E4C',
                pumpkin: '#D83B01',
                zinc: '#505050'
            }[data.theme] || '#6750A4';

            const outerStyle = bwMode ? {
                border: '1px dashed #000', background: 'white'
            } : {
                border: '1px dashed #CCC', background: 'white'
            };

            const innerStyle = {
                background: bwMode ? 'white' : themeColor,
                border: bwMode ? '2px solid black' : 'none',
                color: bwMode ? 'black' : 'white'
            };

            return (
                <div style={{
                    width: '100%', height: '100%', boxSizing: 'border-box',
                    display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
                    padding: '5%', ...outerStyle
                }}>
                    <div style={{
                        width: '100%', height: '100%', borderRadius: 16,
                        display: 'flex', flexDirection: 'column',
                        alignItems: 'center', justifyContent: 'center',
                        padding: '16px 12px', textAlign: 'center',
                        ...innerStyle
                    }}>
                        <Typography variant="h6" style={{ fontWeight: 700, fontSize: '1rem', whiteSpace: 'nowrap' }}>
                            QR을 스캔하세요
                        </Typography>

                        <div style={{
                            display: 'flex', alignItems: 'center', justifyContent: 'center',
                            height: '100%', width: '100%', minHeight: 0, overflow: 'hidden',
                            margin: '8px 0'
                        }}>
                            <img src={qrUrl} style={{
                                maxHeight: '100%', maxWidth: '95%', objectFit: 'contain',
                                borderRadius: 8, border: bwMode ? '4px solid black' : '4px solid white',
                                background: 'white', boxSizing: 'border-box'
                            }} />
                        </div>

                        <Box sx={{ width: '100%', px: 1 }}>
                            <Typography variant="body2" style={{ fontWeight: 600, fontSize: '0.9rem', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                                제목: {data.subject}
                            </Typography>
                            <Typography variant="caption" style={{ display: 'block', fontSize: '0.8rem', opacity: 0.9 }}>
                                보낸 이: {data.senderName}
                            </Typography>
                        </Box>

                        <Typography variant="caption" style={{
                            fontSize: '0.85rem', opacity: 1, fontWeight: 700,
                            wordBreak: 'break-all', lineHeight: 1.2, marginTop: 8,
                            padding: '4px 8px', borderRadius: 4,
                            background: bwMode ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.2)'
                        }}>
                            {data._displayUrl || data.shortUrl || 'is.gd/M2U...'}
                        </Typography>
                    </div>
                </div>
            );
        };

        function App() {
            const [letters, setLetters] = useState([]);
            const [layout, setLayout] = useState(4); // 1, 4, 8 cards per page
            const [duplex, setDuplex] = useState(true); // Duplex layout (Mirror Back)
            const [bwMode, setBwMode] = useState(false); // Black & White Mode
            const [qrUrls, setQrUrls] = useState({});

            useEffect(() => {
                const load = async () => {
                    try {
                        // Load selected IDs from URL param or LocalStorage?
                        // For now, let's assume localStorage 'print_queue'
                        const queueStr = localStorage.getItem('mail2u_print_queue');
                        const queue = queueStr ? JSON.parse(queueStr) : [];
                        const allData = await window.LetterDB.getAll();

                        let targets = [];
                        if (queue && queue.length > 0) {
                            targets = allData.filter(l => queue.includes(l.id));
                        } else {
                            // Fallback: Use last 8 sent letters
                            targets = allData.filter(l => l.mailbox && l.mailbox.includes('sent')).slice(0, 8);
                        }
                        setLetters(targets);

                        // Generate QRs
                        if (!window.QRCode) {
                            console.error("QRCode library not loaded");
                            return;
                        }

                        // Helper: Shorten URL using is.gd
                        const shortenUrl = async (longUrl) => {
                            try {
                                const response = await fetch(`https://is.gd/create.php?format=json&url=${encodeURIComponent(longUrl)}`);
                                const data = await response.json();
                                if (data.shorturl) return data.shorturl;
                                throw new Error(data.errormessage || "Unknown error");
                            } catch (e) {
                                console.error("IS.GD Shorten Error:", e);
                                return null;
                            }
                        };

                        const urls = {};
                        for (const l of targets) {
                            let url = window.LetterDB.toUrl(l, 'view.html');
                            let displayUrl = l.shortUrl || 'is.gd/M2U...'; // Default display

                            // Apply rolling paper QR logic
                            let isRollingPaper = false;
                            try {
                                if (l.messages) {
                                    isRollingPaper = typeof l.messages === 'string'
                                        ? JSON.parse(l.messages).length > 0
                                        : l.messages.length > 0;
                                }
                            } catch (e) {
                                console.warn("Failed to parse messages for letter", l.id, e);
                            }

                            if (isRollingPaper && l.shortUrl) {
                                url = l.shortUrl;
                            }

                            // Try Generating QR
                            try {
                                if (url.length > 300) {
                                    // 1. URL > 300: Always use shortener for better scanning
                                    console.log(`URL length (${url.length}) > 300. Shortening...`);
                                    const short = await shortenUrl(url);
                                    if (short) {
                                        urls[l.id] = await QRCode.toDataURL(short, { margin: 1, errorCorrectionLevel: 'M' });
                                        l._displayUrl = short.replace('https://', '');
                                    } else {
                                        throw new Error("Shortening failed");
                                    }
                                } else {
                                    // 2. URL <= 300: Use Original
                                    urls[l.id] = await QRCode.toDataURL(url, { margin: 1, errorCorrectionLevel: 'M' });
                                }
                            } catch (err) {
                                console.warn(`QR Gen failed for ${l.id} (Length: ${url.length}). Trying fallback...`, err);
                                if (url.length <= 300) {
                                    // If it failed locally but wasn't shortened yet, try shortening now
                                    const short = await shortenUrl(url);
                                    if (short) {
                                        try {
                                            urls[l.id] = await QRCode.toDataURL(short, { margin: 1, errorCorrectionLevel: 'M' });
                                            l._displayUrl = short.replace('https://', '');
                                        } catch (e2) {
                                            console.error(`Final fallback failed for ${l.id}`, e2);
                                        }
                                    }
                                }
                            }

                            // If l._displayUrl exists, we should use it in the component.
                            // However, React state 'letters' is already set. We might need to force update or setLetters again?
                            // Better: Update 'letters' state after processing all QRs if we want to show the new URL text.
                        }

                        // Re-set letters to trigger update with _displayUrl if any
                        setLetters([...targets]);
                        setQrUrls(urls);
                    } catch (e) {
                        console.error("Global error in load effect:", e);
                    }
                };
                load();
            }, []);

            // Calculation
            // Rows/Cols
            const getGrid = (n) => {
                if (n === 1) return { r: 1, c: 1 };
                if (n === 4) return { r: 2, c: 2 };
                if (n === 8) return { r: 4, c: 2 };
                return { r: 2, c: 2 };
            };

            const grid = getGrid(layout);
            const cardW = 210 / grid.c;
            const cardH = 297 / grid.r;

            // Pagination Logic
            const pages = [];
            const perPage = layout;
            const totalSheets = Math.ceil(letters.length / perPage);

            for (let i = 0; i < totalSheets; i++) {
                const sheetLetters = letters.slice(i * perPage, (i + 1) * perPage);
                // Fill remaining slots with null if needed
                while (sheetLetters.length < perPage) sheetLetters.push(null);

                // Front Page
                pages.push({ type: 'front', items: sheetLetters });

                // Back Page (Mirror Logic if duplex)
                // If duplex printing (Long-edge binding assumed for Portrait),
                // Left column on Front becomes Right column on Back.
                // 1 2 -> Back: 2 1
                // 3 4 -> Back: 4 3
                let backItems = [...sheetLetters];
                if (duplex) {
                    // Swap logic for 2-column layout
                    if (grid.c === 2) {
                        const newItems = [];
                        for (let r = 0; r < grid.r; r++) {
                            const left = backItems[r * 2];
                            const right = backItems[r * 2 + 1];
                            newItems.push(right); // push Right first (becomes Left on back)
                            newItems.push(left);  // push Left second (becomes Right on back)
                        }
                        backItems = newItems;
                    }
                }
                pages.push({ type: 'back', items: backItems });
            }

            return (
                <div>
                    <AppBar position="sticky" className="no-print" sx={{ bgcolor: '#333' }}>
                        <Toolbar>
                            <Typography variant="h6" sx={{ flexGrow: 1 }}>카드 인쇄 ({letters.length}장)</Typography>
                            <ToggleButtonGroup value={layout} exclusive onChange={(e, v) => v && setLayout(v)} size="small" sx={{ bg: 'white', mr: 2 }}>
                                <ToggleButton value={1} sx={{ color: 'white' }}>1개</ToggleButton>
                                <ToggleButton value={4} sx={{ color: 'white' }}>4개</ToggleButton>
                                <ToggleButton value={8} sx={{ color: 'white' }}>8개</ToggleButton>
                            </ToggleButtonGroup>
                            <FormControlLabel control={<Checkbox checked={duplex} onChange={e => setDuplex(e.target.checked)} sx={{ color: 'white', '&.Mui-checked': { color: 'lightgreen' } }} />} label="양면(좌우반전)" sx={{ mr: 2 }} />
                            <FormControlLabel control={<Checkbox checked={bwMode} onChange={e => setBwMode(e.target.checked)} sx={{ color: 'white', '&.Mui-checked': { color: 'lightgreen' } }} />} label="흑백모드" sx={{ mr: 2 }} />
                            <Button variant="contained" onClick={() => window.print()}>인쇄하기</Button>
                        </Toolbar>
                    </AppBar>

                    {pages.map((page, pIdx) => (
                        <div key={pIdx} className="page" style={{
                            display: 'grid',
                            gridTemplateColumns: `repeat(${grid.c}, 1fr)`,
                            gridTemplateRows: `repeat(${grid.r}, 1fr)`
                        }}>
                            {page.items.map((item, i) => (
                                <div key={i} style={{ width: '100%', height: '100%' }}>
                                    {item ? (
                                        page.type === 'front' ?
                                            <CardFront data={item} bwMode={bwMode} /> :
                                            <CardBack data={item} qrUrl={qrUrls[item.id]} bwMode={bwMode} />
                                    ) : null}
                                </div>
                            ))}
                        </div>
                    ))}

                    <div className="no-print" style={{ textAlign: 'center', padding: 50, color: '#666' }}>
                        * 인쇄 설정에서 "배경 그래픽"을 꼭 체크해주세요.<br />
                        * 여백은 "없음"으로 설정하세요.
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>